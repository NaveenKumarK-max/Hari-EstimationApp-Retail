/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Output, EventEmitter, ElementRef, ViewChild, Renderer2 } from '@angular/core';
import { EMOJIS } from '../misc/emojis.data';
export class NgxEmojCategoryContentComponent {
    /**
     * @param {?} rd
     */
    constructor(rd) {
        this.rd = rd;
        this.onpickemoji = new EventEmitter;
        this.oncontentscroll = new EventEmitter;
        this.oncontentSwipe = new EventEmitter;
        // @ViewChild('swipePane') swipePane: ElementRef;
        this.searchSet = [];
        this.recentEmosForSearch = [];
        this.initialEmoj = false;
        this.notFound = false;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    search(e) {
        if (!this.initialEmoj) {
            // save the recent emojs
            this.recentEmosForSearch = this.categoryEmojiSet;
            /** @type {?} */
            let searchSet = [];
            for (let i = 2; i < EMOJIS.length; i++) {
                searchSet = searchSet.concat(EMOJIS[i].emojis);
            }
            this.searchSet = searchSet;
            this.initialEmoj = true;
        }
        /** @type {?} */
        const query = e.target.value.toLowerCase();
        if (query && query.trim() !== '') {
            this.categoryEmojiSet = this.searchSet.filter(item => {
                if (item[1].toLowerCase().indexOf(query) > -1) {
                    return item;
                }
            });
        }
        else {
            this.categoryEmojiSet = this.recentEmosForSearch;
        }
        if (this.categoryEmojiSet.length === 0) {
            this.notFound = true;
        }
        else {
            this.notFound = false;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // listen for scroll event
        this.rd.listen(this.emojiContainer.nativeElement, 'scroll', (e) => {
            this.oncontentscroll.emit({
                scrollTop: this.emojiContainer.nativeElement.scrollTop,
                scrollHeight: this.emojiContainer.nativeElement.scrollHeight
            });
        });
        // handle swipe...
        this.swipedetect(this.emojiContainer.nativeElement, (swipedir) => {
            if (swipedir === 'left' || swipedir === 'right') {
                this.oncontentSwipe.emit({
                    direction: swipedir
                });
            }
        });
    }
    /**
     * @param {?} el
     * @param {?} callback
     * @return {?}
     */
    swipedetect(el, callback) {
        /** @type {?} */
        const touchsurface = el;
        /** @type {?} */
        let swipedir;
        /** @type {?} */
        let startX;
        /** @type {?} */
        let startY;
        /** @type {?} */
        let dist;
        /** @type {?} */
        let distX;
        /** @type {?} */
        let distY;
        /** @type {?} */
        const threshold = 150;
        // required min distance traveled to be considered swipe
        /** @type {?} */
        const restraint = 100;
        // maximum distance allowed at the same time in perpendicular direction
        /** @type {?} */
        const allowedTime = 300;
        // maximum time allowed to travel that distance
        /** @type {?} */
        let elapsedTime;
        /** @type {?} */
        let startTime;
        /** @type {?} */
        const handleswipe = callback;
        this.rd.listen(touchsurface, 'touchstart', (e) => {
            /** @type {?} */
            const touchobj = e.changedTouches[0];
            swipedir = 'none';
            dist = 0;
            startX = touchobj.pageX;
            startY = touchobj.pageY;
            startTime = new Date().getTime();
            // record time when finger first makes contact with surface
            // Uncommented this to enale scroll in div
            // e.preventDefault();
        });
        // Uncommented this to enale scroll in div
        // this.rd.listen(touchsurface, 'touchmove', (e) => {
        // prevent scrolling when inside DIV
        // e.preventDefault();
        // });
        this.rd.listen(touchsurface, 'touchend', (e) => {
            /** @type {?} */
            const touchobj = e.changedTouches[0];
            distX = touchobj.pageX - startX; // get horizontal dist traveled by finger while in contact with surface
            distY = touchobj.pageY - startY; // get vertical dist traveled by finger while in contact with surface
            elapsedTime = new Date().getTime() - startTime; // get time elapsed
            if (elapsedTime <= allowedTime) { // first condition for awipe met
                if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint) { // 2nd condition for horizontal swipe met
                    swipedir = (distX < 0) ? 'left' : 'right'; // if dist traveled is negative, it indicates left swipe
                }
                else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint) { // 2nd condition for vertical swipe met
                    swipedir = (distY < 0) ? 'up' : 'down'; // if dist traveled is negative, it indicates up swipe
                }
            }
            handleswipe(swipedir);
            // Uncommented this to enale scroll in div
            // e.preventDefault();
        });
    }
    /**
     * @param {?} emoji
     * @return {?}
     */
    pickEmoji(emoji) {
        this.onpickemoji.emit({
            emoji: emoji
        });
    }
}
NgxEmojCategoryContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-emoj-category-content',
                template: `
  <input *ngIf="activeIndex === 0"  type="text" (keyup)="search($event)" placeholder="{{ searchEmojiPlaceholderText }}"
  class="ngx-emoji-search" [ngStyle]="{'color': searchBoxStyle.FGcolor,
                                       'background': searchBoxStyle.BGcolor,
                                       'border-radius': searchBoxStyle.borderRadius,
                                       'border-color': searchBoxStyle.borderColor}"/>
                                       <div class="ngx-emoji-not-found" *ngIf="activeIndex === 0 && notFound == true"
                                       [ngStyle]="{
                                        'color': martEmojiNotFoundFG
                                        }">
                                        {{ emojiNotFoundText }}
                                       </div>
  <div class="ngx-emoji-category-content" [ngStyle]="{'padding': '5px',
                                           'border-bottom': emojiBtnPadding.y+' solid transparent'}"
                                           #emojiContainer>

      <div class="emoji-btn-container"
        *ngFor="let emo of categoryEmojiSet" [ngStyle]="{'height': emojiBtnPadding.y,
                                                         'width': emojiBtnPadding.x   }">
          <button (click)="pickEmoji(emo)" class="ngx-emoji-emoj-btn"
          [ngStyle]="{'font-size': emojiFontSize}">
      {{ emo[0] }}
    </button>
      </div>
  </div>
  `,
                styles: [`


  .ngx-emoji-not-found
  {
    display: table;
    margin: 60px auto;
    font-size: 15px;
    font-family: sans-serif;
  }

  .ngx-emoji-search
  {
    width: 87%;
    display: table;
    border: 1px solid;
    padding: 5px 10px;
    height: 18px;
    font-family: sans-serif;
    margin: 15px auto 10px auto;
    outline: none;
  }

  .ngx-emoji-category-content
  {
    overflow-y: scroll;
    height: 80%;
    width: 105% !important;
    display: flex;
    flex-wrap: wrap;
    text-align: left;
    align-content: flex-start;
    justify-content: flex-start;
  }

  .emoji-btn-container
  {
    display: flex;
    overflow: hidden;
  }
  .ngx-emoji-emoj-btn
  {
    background: transparent;
    margin: auto;
    border: none;
    outline: none;
    cursor: pointer;
  }
  `]
            }] }
];
/** @nocollapse */
NgxEmojCategoryContentComponent.ctorParameters = () => [
    { type: Renderer2 }
];
NgxEmojCategoryContentComponent.propDecorators = {
    categoryName: [{ type: Input }],
    categoryEmojiSet: [{ type: Input }],
    activeIndex: [{ type: Input }],
    onpickemoji: [{ type: Output }],
    emojiBtnPadding: [{ type: Input }],
    emojiFontSize: [{ type: Input }],
    oncontentscroll: [{ type: Output }],
    oncontentSwipe: [{ type: Output }],
    searchEmojiPlaceholderText: [{ type: Input }],
    searchBoxStyle: [{ type: Input }],
    emojiNotFoundText: [{ type: Input }],
    martEmojiNotFoundFG: [{ type: Input }],
    emojiContainer: [{ type: ViewChild, args: ['emojiContainer',] }]
};
if (false) {
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.categoryName;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.categoryEmojiSet;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.activeIndex;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.onpickemoji;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.emojiBtnPadding;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.emojiFontSize;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.oncontentscroll;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.oncontentSwipe;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.searchEmojiPlaceholderText;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.searchBoxStyle;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.emojiNotFoundText;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.martEmojiNotFoundFG;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.notFound;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.initialEmoj;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.emojiContainer;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.searchSet;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.recentEmosForSearch;
    /**
     * @type {?}
     * @private
     */
    NgxEmojCategoryContentComponent.prototype.rd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2F0ZWdvcnktY29udGVudC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtZW1vai8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2NhdGVnb3J5LWNvbnRlbnQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFVBQVUsRUFDVixTQUFTLEVBQ1QsU0FBUyxFQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDTCxNQUFNLEVBQ1AsTUFBTSxxQkFBcUIsQ0FBQztBQWdGN0IsTUFBTSxPQUFPLCtCQUErQjs7OztJQXdCMUMsWUFBb0IsRUFBYTtRQUFiLE9BQUUsR0FBRixFQUFFLENBQVc7UUFuQnZCLGdCQUFXLEdBQUcsSUFBSSxZQUFZLENBQUM7UUFHL0Isb0JBQWUsR0FBUSxJQUFJLFlBQVksQ0FBQztRQUN4QyxtQkFBYyxHQUFRLElBQUksWUFBWSxDQUFDOztRQVlqRCxjQUFTLEdBQVEsRUFBRSxDQUFDO1FBQ3BCLHdCQUFtQixHQUFRLEVBQUUsQ0FBQztRQUc1QixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztJQUN4QixDQUFDOzs7OztJQUdELE1BQU0sQ0FBQyxDQUFDO1FBRU4sSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDckIsd0JBQXdCO1lBQ3hCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7O2dCQUM3QyxTQUFTLEdBQUcsRUFBRTtZQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdEMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxD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Q3hCLENBQUMsQ0FBQyxDQUFDO0lBRUwsQ0FBQzs7Ozs7SUFHRCxTQUFTLENBQUMsS0FBSztRQUNiLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO1lBQ3BCLEtBQUssRUFBRSxLQUFLO1NBQ2IsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7O1lBL05GLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsMkJBQTJCO2dCQUNyQyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F5QlQ7eUJBQ1E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWdEUjthQUNGOzs7O1lBcEZDLFNBQVM7OzsyQkF1RlIsS0FBSzsrQkFDTCxLQUFLOzBCQUNMLEtBQUs7MEJBQ0wsTUFBTTs4QkFDTixLQUFLOzRCQUNMLEtBQUs7OEJBQ0wsTUFBTTs2QkFDTixNQUFNO3lDQUNOLEtBQUs7NkJBQ0wsS0FBSztnQ0FDTCxLQUFLO2tDQUNMLEtBQUs7NkJBS0wsU0FBUyxTQUFDLGdCQUFnQjs7OztJQWhCM0IsdURBQThCOztJQUM5QiwyREFBK0I7O0lBQy9CLHNEQUE2Qjs7SUFDN0Isc0RBQXlDOztJQUN6QywwREFBOEI7O0lBQzlCLHdEQUErQjs7SUFDL0IsMERBQWtEOztJQUNsRCx5REFBaUQ7O0lBQ2pELHFFQUE0Qzs7SUFDNUMseURBQTZCOztJQUM3Qiw0REFBbUM7O0lBQ25DLDhEQUFxQzs7SUFFckMsbURBQWtCOztJQUNsQixzREFBcUI7O0lBRXJCLHlEQUF3RDs7SUFHeEQsb0RBQW9COztJQUNwQiw4REFBOEI7Ozs7O0lBRWxCLDZDQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQ29tcG9uZW50LFxyXG4gIElucHV0LFxyXG4gIE91dHB1dCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgRWxlbWVudFJlZixcclxuICBWaWV3Q2hpbGQsXHJcbiAgUmVuZGVyZXIyLFxyXG4gIEFmdGVyVmlld0luaXRcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtcclxuICBFTU9KSVNcclxufSBmcm9tICcuLi9taXNjL2Vtb2ppcy5kYXRhJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnbmd4LWVtb2otY2F0ZWdvcnktY29udGVudCcsXHJcbiAgdGVtcGxhdGU6IGBcclxuICA8aW5wdXQgKm5nSWY9XCJhY3RpdmVJbmRleCA9PT0gMFwiICB0eXBlPVwidGV4dFwiIChrZXl1cCk9XCJzZWFyY2goJGV2ZW50KVwiIHBsYWNlaG9sZGVyPVwie3sgc2VhcmNoRW1vamlQbGFjZWhvbGRlclRleHQgfX1cIlxyXG4gIGNsYXNzPVwibmd4LWVtb2ppLXNlYXJjaFwiIFtuZ1N0eWxlXT1cInsnY29sb3InOiBzZWFyY2hCb3hTdHlsZS5GR2NvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZCc6IHNlYXJjaEJveFN0eWxlLkJHY29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdib3JkZXItcmFkaXVzJzogc2VhcmNoQm94U3R5bGUuYm9yZGVyUmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogc2VhcmNoQm94U3R5bGUuYm9yZGVyQ29sb3J9XCIvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmd4LWVtb2ppLW5vdC1mb3VuZFwiICpuZ0lmPVwiYWN0aXZlSW5kZXggPT09IDAgJiYgbm90Rm91bmQgPT0gdHJ1ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1N0eWxlXT1cIntcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2xvcic6IG1hcnRFbW9qaU5vdEZvdW5kRkdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IGVtb2ppTm90Rm91bmRUZXh0IH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gIDxkaXYgY2xhc3M9XCJuZ3gtZW1vamktY2F0ZWdvcnktY29udGVudFwiIFtuZ1N0eWxlXT1cInsncGFkZGluZyc6ICc1cHgnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcmRlci1ib3R0b20nOiBlbW9qaUJ0blBhZGRpbmcueSsnIHNvbGlkIHRyYW5zcGFyZW50J31cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI2Vtb2ppQ29udGFpbmVyPlxyXG5cclxuICAgICAgPGRpdiBjbGFzcz1cImVtb2ppLWJ0bi1jb250YWluZXJcIlxyXG4gICAgICAgICpuZ0Zvcj1cImxldCBlbW8gb2YgY2F0ZWdvcnlFbW9qaVNldFwiIFtuZ1N0eWxlXT1cInsnaGVpZ2h0JzogZW1vamlCdG5QYWRkaW5nLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3aWR0aCc6IGVtb2ppQnRuUGFkZGluZy54ICAgfVwiPlxyXG4gICAgICAgICAgPGJ1dHRvbiAoY2xpY2spPVwicGlja0Vtb2ppKGVtbylcIiBjbGFzcz1cIm5neC1lbW9qaS1lbW9qLWJ0blwiXHJcbiAgICAgICAgICBbbmdTdHlsZV09XCJ7J2ZvbnQtc2l6ZSc6IGVtb2ppRm9udFNpemV9XCI+XHJcbiAgICAgIHt7IGVtb1swXSB9fVxyXG4gICAgPC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG4gIGAsXHJcbiAgc3R5bGVzOiBbYFxyXG5cclxuXHJcbiAgLm5neC1lbW9qaS1ub3QtZm91bmRcclxuICB7XHJcbiAgICBkaXNwbGF5OiB0YWJsZTtcclxuICAgIG1hcmdpbjogNjBweCBhdXRvO1xyXG4gICAgZm9udC1zaXplOiAxNXB4O1xyXG4gICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XHJcbiAgfVxyXG5cclxuICAubmd4LWVtb2ppLXNlYXJjaFxyXG4gIHtcclxuICAgIHdpZHRoOiA4NyU7XHJcbiAgICBkaXNwbGF5OiB0YWJsZTtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkO1xyXG4gICAgcGFkZGluZzogNXB4IDEwcHg7XHJcbiAgICBoZWlnaHQ6IDE4cHg7XHJcbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcclxuICAgIG1hcmdpbjogMTVweCBhdXRvIDEwcHggYXV0bztcclxuICAgIG91dGxpbmU6IG5vbmU7XHJcbiAgfVxyXG5cclxuICAubmd4LWVtb2ppLWNhdGVnb3J5LWNvbnRlbnRcclxuICB7XHJcbiAgICBvdmVyZmxvdy15OiBzY3JvbGw7XHJcbiAgICBoZWlnaHQ6IDgwJTtcclxuICAgIHdpZHRoOiAxMDUlICFpbXBvcnRhbnQ7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC13cmFwOiB3cmFwO1xyXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcclxuICAgIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XHJcbiAgfVxyXG5cclxuICAuZW1vamktYnRuLWNvbnRhaW5lclxyXG4gIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gIH1cclxuICAubmd4LWVtb2ppLWVtb2otYnRuXHJcbiAge1xyXG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XHJcbiAgICBtYXJnaW46IGF1dG87XHJcbiAgICBib3JkZXI6IG5vbmU7XHJcbiAgICBvdXRsaW5lOiBub25lO1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gIH1cclxuICBgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4RW1vakNhdGVnb3J5Q29udGVudENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xyXG5cclxuICBASW5wdXQoKSBjYXRlZ29yeU5hbWU6IHN0cmluZztcclxuICBASW5wdXQoKSBjYXRlZ29yeUVtb2ppU2V0OiBhbnk7XHJcbiAgQElucHV0KCkgYWN0aXZlSW5kZXg6IG51bWJlcjtcclxuICBAT3V0cHV0KCkgb25waWNrZW1vamkgPSBuZXcgRXZlbnRFbWl0dGVyO1xyXG4gIEBJbnB1dCgpIGVtb2ppQnRuUGFkZGluZzogYW55O1xyXG4gIEBJbnB1dCgpIGVtb2ppRm9udFNpemU6IHN0cmluZztcclxuICBAT3V0cHV0KCkgb25jb250ZW50c2Nyb2xsOiBhbnkgPSBuZXcgRXZlbnRFbWl0dGVyO1xyXG4gIEBPdXRwdXQoKSBvbmNvbnRlbnRTd2lwZTogYW55ID0gbmV3IEV2ZW50RW1pdHRlcjtcclxuICBASW5wdXQoKSBzZWFyY2hFbW9qaVBsYWNlaG9sZGVyVGV4dDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIHNlYXJjaEJveFN0eWxlOiBhbnk7XHJcbiAgQElucHV0KCkgZW1vamlOb3RGb3VuZFRleHQ6IHN0cmluZztcclxuICBASW5wdXQoKSBtYXJ0RW1vamlOb3RGb3VuZEZHOiBzdHJpbmc7XHJcblxyXG4gIG5vdEZvdW5kOiBib29sZWFuO1xyXG4gIGluaXRpYWxFbW9qOiBib29sZWFuO1xyXG5cclxuICBAVmlld0NoaWxkKCdlbW9qaUNvbnRhaW5lcicpIGVtb2ppQ29udGFpbmVyOiBFbGVtZW50UmVmO1xyXG4gIC8vIEBWaWV3Q2hpbGQoJ3N3aXBlUGFuZScpIHN3aXBlUGFuZTogRWxlbWVudFJlZjtcclxuXHJcbiAgc2VhcmNoU2V0OiBhbnkgPSBbXTtcclxuICByZWNlbnRFbW9zRm9yU2VhcmNoOiBhbnkgPSBbXTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZDogUmVuZGVyZXIyKSB7XHJcbiAgICB0aGlzLmluaXRpYWxFbW9qID0gZmFsc2U7XHJcbiAgICB0aGlzLm5vdEZvdW5kID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuXHJcbiAgc2VhcmNoKGUpIHtcclxuXHJcbiAgICBpZiAoIXRoaXMuaW5pdGlhbEVtb2opIHtcclxuICAgICAgLy8gc2F2ZSB0aGUgcmVjZW50IGVtb2pzXHJcbiAgICAgIHRoaXMucmVjZW50RW1vc0ZvclNlYXJjaCA9IHRoaXMuY2F0ZWdvcnlFbW9qaVNldDtcclxuICAgICAgbGV0IHNlYXJjaFNldCA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpID0gMjsgaSA8IEVNT0pJUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHNlYXJjaFNldCA9IHNlYXJjaFNldC5jb25jYXQoRU1PSklTW2ldLmVtb2ppcyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5zZWFyY2hTZXQgPSBzZWFyY2hTZXQ7XHJcbiAgICAgIHRoaXMuaW5pdGlhbEVtb2ogPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcXVlcnkgPSBlLnRhcmdldC52YWx1ZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIGlmIChxdWVyeSAmJiBxdWVyeS50cmltKCkgIT09ICcnKSB7XHJcbiAgICAgIHRoaXMuY2F0ZWdvcnlFbW9qaVNldCA9IHRoaXMuc2VhcmNoU2V0LmZpbHRlcihpdGVtID0+IHtcclxuICAgICAgICBpZiAoaXRlbVsxXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocXVlcnkpID4gLTEpIHtcclxuICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jYXRlZ29yeUVtb2ppU2V0ID0gdGhpcy5yZWNlbnRFbW9zRm9yU2VhcmNoO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY2F0ZWdvcnlFbW9qaVNldC5sZW5ndGggPT09IDApIHtcclxuICAgICAgdGhpcy5ub3RGb3VuZCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLm5vdEZvdW5kID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCkge1xyXG5cclxuICAgIC8vIGxpc3RlbiBmb3Igc2Nyb2xsIGV2ZW50XHJcbiAgICB0aGlzLnJkLmxpc3Rlbih0aGlzLmVtb2ppQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsICdzY3JvbGwnLCAoZSkgPT4ge1xyXG4gICAgICB0aGlzLm9uY29udGVudHNjcm9sbC5lbWl0KHtcclxuICAgICAgICBzY3JvbGxUb3A6IHRoaXMuZW1vamlDb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AsXHJcbiAgICAgICAgc2Nyb2xsSGVpZ2h0OiB0aGlzLmVtb2ppQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gaGFuZGxlIHN3aXBlLi4uXHJcblxyXG4gICAgdGhpcy5zd2lwZWRldGVjdCh0aGlzLmVtb2ppQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQsIChzd2lwZWRpcikgPT4ge1xyXG5cclxuICAgICAgaWYgKHN3aXBlZGlyID09PSAnbGVmdCcgfHwgc3dpcGVkaXIgPT09ICdyaWdodCcpIHtcclxuICAgICAgICB0aGlzLm9uY29udGVudFN3aXBlLmVtaXQoe1xyXG4gICAgICAgICAgZGlyZWN0aW9uOiBzd2lwZWRpclxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHN3aXBlZGV0ZWN0KGVsLCBjYWxsYmFjaykge1xyXG5cclxuICAgIGNvbnN0IHRvdWNoc3VyZmFjZSA9IGVsO1xyXG4gICAgbGV0IHN3aXBlZGlyLFxyXG4gICAgICBzdGFydFgsXHJcbiAgICAgIHN0YXJ0WSxcclxuICAgICAgZGlzdCxcclxuICAgICAgZGlzdFgsXHJcbiAgICAgIGRpc3RZO1xyXG4gICAgY29uc3QgdGhyZXNob2xkID0gMTUwOyAvLyByZXF1aXJlZCBtaW4gZGlzdGFuY2UgdHJhdmVsZWQgdG8gYmUgY29uc2lkZXJlZCBzd2lwZVxyXG4gICAgY29uc3QgcmVzdHJhaW50ID0gMTAwOyAvLyBtYXhpbXVtIGRpc3RhbmNlIGFsbG93ZWQgYXQgdGhlIHNhbWUgdGltZSBpbiBwZXJwZW5kaWN1bGFyIGRpcmVjdGlvblxyXG4gICAgY29uc3QgYWxsb3dlZFRpbWUgPSAzMDA7IC8vIG1heGltdW0gdGltZSBhbGxvd2VkIHRvIHRyYXZlbCB0aGF0IGRpc3RhbmNlXHJcbiAgICBsZXQgZWxhcHNlZFRpbWUsXHJcbiAgICAgIHN0YXJ0VGltZTtcclxuICAgIGNvbnN0IGhhbmRsZXN3aXBlID0gY2FsbGJhY2s7XHJcblxyXG4gICAgdGhpcy5yZC5saXN0ZW4odG91Y2hzdXJmYWNlLCAndG91Y2hzdGFydCcsIChlKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRvdWNob2JqID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcclxuICAgICAgc3dpcGVkaXIgPSAnbm9uZSc7XHJcbiAgICAgIGRpc3QgPSAwO1xyXG4gICAgICBzdGFydFggPSB0b3VjaG9iai5wYWdlWDtcclxuICAgICAgc3RhcnRZID0gdG91Y2hvYmoucGFnZVk7XHJcbiAgICAgIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAvLyByZWNvcmQgdGltZSB3aGVuIGZpbmdlciBmaXJzdCBtYWtlcyBjb250YWN0IHdpdGggc3VyZmFjZVxyXG5cclxuICAgICAgLy8gVW5jb21tZW50ZWQgdGhpcyB0byBlbmFsZSBzY3JvbGwgaW4gZGl2XHJcbiAgICAgIC8vIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLy8gVW5jb21tZW50ZWQgdGhpcyB0byBlbmFsZSBzY3JvbGwgaW4gZGl2XHJcbiAgICAvLyB0aGlzLnJkLmxpc3Rlbih0b3VjaHN1cmZhY2UsICd0b3VjaG1vdmUnLCAoZSkgPT4ge1xyXG4gICAgLy8gcHJldmVudCBzY3JvbGxpbmcgd2hlbiBpbnNpZGUgRElWXHJcbiAgICAvLyBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAvLyB9KTtcclxuXHJcbiAgICB0aGlzLnJkLmxpc3Rlbih0b3VjaHN1cmZhY2UsICd0b3VjaGVuZCcsIChlKSA9PiB7XHJcbiAgICAgIGNvbnN0IHRvdWNob2JqID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcclxuICAgICAgZGlzdFggPSB0b3VjaG9iai5wYWdlWCAtIHN0YXJ0WDsgLy8gZ2V0IGhvcml6b250YWwgZGlzdCB0cmF2ZWxlZCBieSBmaW5nZXIgd2hpbGUgaW4gY29udGFjdCB3aXRoIHN1cmZhY2VcclxuICAgICAgZGlzdFkgPSB0b3VjaG9iai5wYWdlWSAtIHN0YXJ0WTsgLy8gZ2V0IHZlcnRpY2FsIGRpc3QgdHJhdmVsZWQgYnkgZmluZ2VyIHdoaWxlIGluIGNvbnRhY3Qgd2l0aCBzdXJmYWNlXHJcbiAgICAgIGVsYXBzZWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWU7IC8vIGdldCB0aW1lIGVsYXBzZWRcclxuICAgICAgaWYgKGVsYXBzZWRUaW1lIDw9IGFsbG93ZWRUaW1lKSB7IC8vIGZpcnN0IGNvbmRpdGlvbiBmb3IgYXdpcGUgbWV0XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpc3RYKSA+PSB0aHJlc2hvbGQgJiYgTWF0aC5hYnMoZGlzdFkpIDw9IHJlc3RyYWludCkgeyAvLyAybmQgY29uZGl0aW9uIGZvciBob3Jpem9udGFsIHN3aXBlIG1ldFxyXG4gICAgICAgICAgc3dpcGVkaXIgPSAoZGlzdFggPCAwKSA/ICdsZWZ0JyA6ICdyaWdodCc7IC8vIGlmIGRpc3QgdHJhdmVsZWQgaXMgbmVnYXRpdmUsIGl0IGluZGljYXRlcyBsZWZ0IHN3aXBlXHJcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhkaXN0WSkgPj0gdGhyZXNob2xkICYmIE1hdGguYWJzKGRpc3RYKSA8PSByZXN0cmFpbnQpIHsgLy8gMm5kIGNvbmRpdGlvbiBmb3IgdmVydGljYWwgc3dpcGUgbWV0XHJcbiAgICAgICAgICBzd2lwZWRpciA9IChkaXN0WSA8IDApID8gJ3VwJyA6ICdkb3duJzsgLy8gaWYgZGlzdCB0cmF2ZWxlZCBpcyBuZWdhdGl2ZSwgaXQgaW5kaWNhdGVzIHVwIHN3aXBlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGhhbmRsZXN3aXBlKHN3aXBlZGlyKTtcclxuICAgICAgLy8gVW5jb21tZW50ZWQgdGhpcyB0byBlbmFsZSBzY3JvbGwgaW4gZGl2XHJcbiAgICAgIC8vIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH0pO1xyXG5cclxuICB9XHJcblxyXG5cclxuICBwaWNrRW1vamkoZW1vamkpIHtcclxuICAgIHRoaXMub25waWNrZW1vamkuZW1pdCh7XHJcbiAgICAgIGVtb2ppOiBlbW9qaVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuXHJcblxyXG5cclxufVxyXG4iXX0=