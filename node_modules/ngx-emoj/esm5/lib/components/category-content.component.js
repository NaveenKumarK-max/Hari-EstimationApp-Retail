/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input, Output, EventEmitter, ElementRef, ViewChild, Renderer2 } from '@angular/core';
import { EMOJIS } from '../misc/emojis.data';
var NgxEmojCategoryContentComponent = /** @class */ (function () {
    function NgxEmojCategoryContentComponent(rd) {
        this.rd = rd;
        this.onpickemoji = new EventEmitter;
        this.oncontentscroll = new EventEmitter;
        this.oncontentSwipe = new EventEmitter;
        // @ViewChild('swipePane') swipePane: ElementRef;
        this.searchSet = [];
        this.recentEmosForSearch = [];
        this.initialEmoj = false;
        this.notFound = false;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    NgxEmojCategoryContentComponent.prototype.search = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (!this.initialEmoj) {
            // save the recent emojs
            this.recentEmosForSearch = this.categoryEmojiSet;
            /** @type {?} */
            var searchSet = [];
            for (var i = 2; i < EMOJIS.length; i++) {
                searchSet = searchSet.concat(EMOJIS[i].emojis);
            }
            this.searchSet = searchSet;
            this.initialEmoj = true;
        }
        /** @type {?} */
        var query = e.target.value.toLowerCase();
        if (query && query.trim() !== '') {
            this.categoryEmojiSet = this.searchSet.filter(function (item) {
                if (item[1].toLowerCase().indexOf(query) > -1) {
                    return item;
                }
            });
        }
        else {
            this.categoryEmojiSet = this.recentEmosForSearch;
        }
        if (this.categoryEmojiSet.length === 0) {
            this.notFound = true;
        }
        else {
            this.notFound = false;
        }
    };
    /**
     * @return {?}
     */
    NgxEmojCategoryContentComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // listen for scroll event
        this.rd.listen(this.emojiContainer.nativeElement, 'scroll', function (e) {
            _this.oncontentscroll.emit({
                scrollTop: _this.emojiContainer.nativeElement.scrollTop,
                scrollHeight: _this.emojiContainer.nativeElement.scrollHeight
            });
        });
        // handle swipe...
        this.swipedetect(this.emojiContainer.nativeElement, function (swipedir) {
            if (swipedir === 'left' || swipedir === 'right') {
                _this.oncontentSwipe.emit({
                    direction: swipedir
                });
            }
        });
    };
    /**
     * @param {?} el
     * @param {?} callback
     * @return {?}
     */
    NgxEmojCategoryContentComponent.prototype.swipedetect = /**
     * @param {?} el
     * @param {?} callback
     * @return {?}
     */
    function (el, callback) {
        /** @type {?} */
        var touchsurface = el;
        /** @type {?} */
        var swipedir;
        /** @type {?} */
        var startX;
        /** @type {?} */
        var startY;
        /** @type {?} */
        var dist;
        /** @type {?} */
        var distX;
        /** @type {?} */
        var distY;
        /** @type {?} */
        var threshold = 150;
        // required min distance traveled to be considered swipe
        /** @type {?} */
        var restraint = 100;
        // maximum distance allowed at the same time in perpendicular direction
        /** @type {?} */
        var allowedTime = 300;
        // maximum time allowed to travel that distance
        /** @type {?} */
        var elapsedTime;
        /** @type {?} */
        var startTime;
        /** @type {?} */
        var handleswipe = callback;
        this.rd.listen(touchsurface, 'touchstart', function (e) {
            /** @type {?} */
            var touchobj = e.changedTouches[0];
            swipedir = 'none';
            dist = 0;
            startX = touchobj.pageX;
            startY = touchobj.pageY;
            startTime = new Date().getTime();
            // record time when finger first makes contact with surface
            // Uncommented this to enale scroll in div
            // e.preventDefault();
        });
        // Uncommented this to enale scroll in div
        // this.rd.listen(touchsurface, 'touchmove', (e) => {
        // prevent scrolling when inside DIV
        // e.preventDefault();
        // });
        this.rd.listen(touchsurface, 'touchend', function (e) {
            /** @type {?} */
            var touchobj = e.changedTouches[0];
            distX = touchobj.pageX - startX; // get horizontal dist traveled by finger while in contact with surface
            distY = touchobj.pageY - startY; // get vertical dist traveled by finger while in contact with surface
            elapsedTime = new Date().getTime() - startTime; // get time elapsed
            if (elapsedTime <= allowedTime) { // first condition for awipe met
                if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint) { // 2nd condition for horizontal swipe met
                    swipedir = (distX < 0) ? 'left' : 'right'; // if dist traveled is negative, it indicates left swipe
                }
                else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint) { // 2nd condition for vertical swipe met
                    swipedir = (distY < 0) ? 'up' : 'down'; // if dist traveled is negative, it indicates up swipe
                }
            }
            handleswipe(swipedir);
            // Uncommented this to enale scroll in div
            // e.preventDefault();
        });
    };
    /**
     * @param {?} emoji
     * @return {?}
     */
    NgxEmojCategoryContentComponent.prototype.pickEmoji = /**
     * @param {?} emoji
     * @return {?}
     */
    function (emoji) {
        this.onpickemoji.emit({
            emoji: emoji
        });
    };
    NgxEmojCategoryContentComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ngx-emoj-category-content',
                    template: "\n  <input *ngIf=\"activeIndex === 0\"  type=\"text\" (keyup)=\"search($event)\" placeholder=\"{{ searchEmojiPlaceholderText }}\"\n  class=\"ngx-emoji-search\" [ngStyle]=\"{'color': searchBoxStyle.FGcolor,\n                                       'background': searchBoxStyle.BGcolor,\n                                       'border-radius': searchBoxStyle.borderRadius,\n                                       'border-color': searchBoxStyle.borderColor}\"/>\n                                       <div class=\"ngx-emoji-not-found\" *ngIf=\"activeIndex === 0 && notFound == true\"\n                                       [ngStyle]=\"{\n                                        'color': martEmojiNotFoundFG\n                                        }\">\n                                        {{ emojiNotFoundText }}\n                                       </div>\n  <div class=\"ngx-emoji-category-content\" [ngStyle]=\"{'padding': '5px',\n                                           'border-bottom': emojiBtnPadding.y+' solid transparent'}\"\n                                           #emojiContainer>\n\n      <div class=\"emoji-btn-container\"\n        *ngFor=\"let emo of categoryEmojiSet\" [ngStyle]=\"{'height': emojiBtnPadding.y,\n                                                         'width': emojiBtnPadding.x   }\">\n          <button (click)=\"pickEmoji(emo)\" class=\"ngx-emoji-emoj-btn\"\n          [ngStyle]=\"{'font-size': emojiFontSize}\">\n      {{ emo[0] }}\n    </button>\n      </div>\n  </div>\n  ",
                    styles: ["\n\n\n  .ngx-emoji-not-found\n  {\n    display: table;\n    margin: 60px auto;\n    font-size: 15px;\n    font-family: sans-serif;\n  }\n\n  .ngx-emoji-search\n  {\n    width: 87%;\n    display: table;\n    border: 1px solid;\n    padding: 5px 10px;\n    height: 18px;\n    font-family: sans-serif;\n    margin: 15px auto 10px auto;\n    outline: none;\n  }\n\n  .ngx-emoji-category-content\n  {\n    overflow-y: scroll;\n    height: 80%;\n    width: 105% !important;\n    display: flex;\n    flex-wrap: wrap;\n    text-align: left;\n    align-content: flex-start;\n    justify-content: flex-start;\n  }\n\n  .emoji-btn-container\n  {\n    display: flex;\n    overflow: hidden;\n  }\n  .ngx-emoji-emoj-btn\n  {\n    background: transparent;\n    margin: auto;\n    border: none;\n    outline: none;\n    cursor: pointer;\n  }\n  "]
                }] }
    ];
    /** @nocollapse */
    NgxEmojCategoryContentComponent.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    NgxEmojCategoryContentComponent.propDecorators = {
        categoryName: [{ type: Input }],
        categoryEmojiSet: [{ type: Input }],
        activeIndex: [{ type: Input }],
        onpickemoji: [{ type: Output }],
        emojiBtnPadding: [{ type: Input }],
        emojiFontSize: [{ type: Input }],
        oncontentscroll: [{ type: Output }],
        oncontentSwipe: [{ type: Output }],
        searchEmojiPlaceholderText: [{ type: Input }],
        searchBoxStyle: [{ type: Input }],
        emojiNotFoundText: [{ type: Input }],
        martEmojiNotFoundFG: [{ type: Input }],
        emojiContainer: [{ type: ViewChild, args: ['emojiContainer',] }]
    };
    return NgxEmojCategoryContentComponent;
}());
export { NgxEmojCategoryContentComponent };
if (false) {
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.categoryName;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.categoryEmojiSet;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.activeIndex;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.onpickemoji;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.emojiBtnPadding;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.emojiFontSize;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.oncontentscroll;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.oncontentSwipe;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.searchEmojiPlaceholderText;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.searchBoxStyle;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.emojiNotFoundText;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.martEmojiNotFoundFG;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.notFound;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.initialEmoj;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.emojiContainer;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.searchSet;
    /** @type {?} */
    NgxEmojCategoryContentComponent.prototype.recentEmosForSearch;
    /**
     * @type {?}
     * @private
     */
    NgxEmojCategoryContentComponent.prototype.rd;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2F0ZWdvcnktY29udGVudC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtZW1vai8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL2NhdGVnb3J5LWNvbnRlbnQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFVBQVUsRUFDVixTQUFTLEVBQ1QsU0FBUyxFQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFDTCxNQUFNLEVBQ1AsTUFBTSxxQkFBcUIsQ0FBQztBQUU3QjtJQXNHRSx5Q0FBb0IsRUFBYTtRQUFiLE9BQUUsR0FBRixFQUFFLENBQVc7UUFuQnZCLGdCQUFXLEdBQUcsSUFBSSxZQUFZLENBQUM7UUFHL0Isb0JBQWUsR0FBUSxJQUFJLFlBQVksQ0FBQztRQUN4QyxtQkFBYyxHQUFRLElBQUksWUFBWSxDQUFDOztRQVlqRCxjQUFTLEdBQVEsRUFBRSxDQUFDO1FBQ3BCLHdCQUFtQixHQUFRLEVBQUUsQ0FBQztRQUc1QixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztJQUN4QixDQUFDOzs7OztJQUdELGdEQUFNOzs7O0lBQU4sVUFBTyxDQUFDO1FBRU4sSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDckIsd0JBQXdCO1lBQ3hCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7O2dCQUM3QyxTQUFTLEdBQUcsRUFBRTtZQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdEMsU0FBUyxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FB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QUM7Ozs7O0lBR0QsbURBQVM7Ozs7SUFBVCxVQUFVLEtBQUs7UUFDYixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztZQUNwQixLQUFLLEVBQUUsS0FBSztTQUNiLENBQUMsQ0FBQztJQUNMLENBQUM7O2dCQS9ORixTQUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLDJCQUEyQjtvQkFDckMsUUFBUSxFQUFFLG0vQ0F5QlQ7NkJBQ1EsK3pCQWdEUjtpQkFDRjs7OztnQkFwRkMsU0FBUzs7OytCQXVGUixLQUFLO21DQUNMLEtBQUs7OEJBQ0wsS0FBSzs4QkFDTCxNQUFNO2tDQUNOLEtBQUs7Z0NBQ0wsS0FBSztrQ0FDTCxNQUFNO2lDQUNOLE1BQU07NkNBQ04sS0FBSztpQ0FDTCxLQUFLO29DQUNMLEtBQUs7c0NBQ0wsS0FBSztpQ0FLTCxTQUFTLFNBQUMsZ0JBQWdCOztJQW9JN0Isc0NBQUM7Q0FBQSxBQXBPRCxJQW9PQztTQXRKWSwrQkFBK0I7OztJQUUxQyx1REFBOEI7O0lBQzlCLDJEQUErQjs7SUFDL0Isc0RBQTZCOztJQUM3QixzREFBeUM7O0lBQ3pDLDBEQUE4Qjs7SUFDOUIsd0RBQStCOztJQUMvQiwwREFBa0Q7O0lBQ2xELHlEQUFpRDs7SUFDakQscUVBQTRDOztJQUM1Qyx5REFBNkI7O0lBQzdCLDREQUFtQzs7SUFDbkMsOERBQXFDOztJQUVyQyxtREFBa0I7O0lBQ2xCLHNEQUFxQjs7SUFFckIseURBQXdEOztJQUd4RCxvREFBb0I7O0lBQ3BCLDhEQUE4Qjs7Ozs7SUFFbEIsNkNBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDb21wb25lbnQsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBFbGVtZW50UmVmLFxyXG4gIFZpZXdDaGlsZCxcclxuICBSZW5kZXJlcjIsXHJcbiAgQWZ0ZXJWaWV3SW5pdFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIEVNT0pJU1xyXG59IGZyb20gJy4uL21pc2MvZW1vamlzLmRhdGEnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICduZ3gtZW1vai1jYXRlZ29yeS1jb250ZW50JyxcclxuICB0ZW1wbGF0ZTogYFxyXG4gIDxpbnB1dCAqbmdJZj1cImFjdGl2ZUluZGV4ID09PSAwXCIgIHR5cGU9XCJ0ZXh0XCIgKGtleXVwKT1cInNlYXJjaCgkZXZlbnQpXCIgcGxhY2Vob2xkZXI9XCJ7eyBzZWFyY2hFbW9qaVBsYWNlaG9sZGVyVGV4dCB9fVwiXHJcbiAgY2xhc3M9XCJuZ3gtZW1vamktc2VhcmNoXCIgW25nU3R5bGVdPVwieydjb2xvcic6IHNlYXJjaEJveFN0eWxlLkZHY29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdiYWNrZ3JvdW5kJzogc2VhcmNoQm94U3R5bGUuQkdjb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JvcmRlci1yYWRpdXMnOiBzZWFyY2hCb3hTdHlsZS5ib3JkZXJSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdib3JkZXItY29sb3InOiBzZWFyY2hCb3hTdHlsZS5ib3JkZXJDb2xvcn1cIi8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZ3gtZW1vamktbm90LWZvdW5kXCIgKm5nSWY9XCJhY3RpdmVJbmRleCA9PT0gMCAmJiBub3RGb3VuZCA9PSB0cnVlXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nU3R5bGVdPVwie1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbG9yJzogbWFydEVtb2ppTm90Rm91bmRGR1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgZW1vamlOb3RGb3VuZFRleHQgfX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cIm5neC1lbW9qaS1jYXRlZ29yeS1jb250ZW50XCIgW25nU3R5bGVdPVwieydwYWRkaW5nJzogJzVweCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYm9yZGVyLWJvdHRvbSc6IGVtb2ppQnRuUGFkZGluZy55Kycgc29saWQgdHJhbnNwYXJlbnQnfVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjZW1vamlDb250YWluZXI+XHJcblxyXG4gICAgICA8ZGl2IGNsYXNzPVwiZW1vamktYnRuLWNvbnRhaW5lclwiXHJcbiAgICAgICAgKm5nRm9yPVwibGV0IGVtbyBvZiBjYXRlZ29yeUVtb2ppU2V0XCIgW25nU3R5bGVdPVwieydoZWlnaHQnOiBlbW9qaUJ0blBhZGRpbmcueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJzogZW1vamlCdG5QYWRkaW5nLnggICB9XCI+XHJcbiAgICAgICAgICA8YnV0dG9uIChjbGljayk9XCJwaWNrRW1vamkoZW1vKVwiIGNsYXNzPVwibmd4LWVtb2ppLWVtb2otYnRuXCJcclxuICAgICAgICAgIFtuZ1N0eWxlXT1cInsnZm9udC1zaXplJzogZW1vamlGb250U2l6ZX1cIj5cclxuICAgICAge3sgZW1vWzBdIH19XHJcbiAgICA8L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbiAgYCxcclxuICBzdHlsZXM6IFtgXHJcblxyXG5cclxuICAubmd4LWVtb2ppLW5vdC1mb3VuZFxyXG4gIHtcclxuICAgIGRpc3BsYXk6IHRhYmxlO1xyXG4gICAgbWFyZ2luOiA2MHB4IGF1dG87XHJcbiAgICBmb250LXNpemU6IDE1cHg7XHJcbiAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcclxuICB9XHJcblxyXG4gIC5uZ3gtZW1vamktc2VhcmNoXHJcbiAge1xyXG4gICAgd2lkdGg6IDg3JTtcclxuICAgIGRpc3BsYXk6IHRhYmxlO1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQ7XHJcbiAgICBwYWRkaW5nOiA1cHggMTBweDtcclxuICAgIGhlaWdodDogMThweDtcclxuICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xyXG4gICAgbWFyZ2luOiAxNXB4IGF1dG8gMTBweCBhdXRvO1xyXG4gICAgb3V0bGluZTogbm9uZTtcclxuICB9XHJcblxyXG4gIC5uZ3gtZW1vamktY2F0ZWdvcnktY29udGVudFxyXG4gIHtcclxuICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcclxuICAgIGhlaWdodDogODAlO1xyXG4gICAgd2lkdGg6IDEwNSUgIWltcG9ydGFudDtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LXdyYXA6IHdyYXA7XHJcbiAgICB0ZXh0LWFsaWduOiBsZWZ0O1xyXG4gICAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcclxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcclxuICB9XHJcblxyXG4gIC5lbW9qaS1idG4tY29udGFpbmVyXHJcbiAge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgfVxyXG4gIC5uZ3gtZW1vamktZW1vai1idG5cclxuICB7XHJcbiAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcclxuICAgIG1hcmdpbjogYXV0bztcclxuICAgIGJvcmRlcjogbm9uZTtcclxuICAgIG91dGxpbmU6IG5vbmU7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgfVxyXG4gIGBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOZ3hFbW9qQ2F0ZWdvcnlDb250ZW50Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XHJcblxyXG4gIEBJbnB1dCgpIGNhdGVnb3J5TmFtZTogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIGNhdGVnb3J5RW1vamlTZXQ6IGFueTtcclxuICBASW5wdXQoKSBhY3RpdmVJbmRleDogbnVtYmVyO1xyXG4gIEBPdXRwdXQoKSBvbnBpY2tlbW9qaSA9IG5ldyBFdmVudEVtaXR0ZXI7XHJcbiAgQElucHV0KCkgZW1vamlCdG5QYWRkaW5nOiBhbnk7XHJcbiAgQElucHV0KCkgZW1vamlGb250U2l6ZTogc3RyaW5nO1xyXG4gIEBPdXRwdXQoKSBvbmNvbnRlbnRzY3JvbGw6IGFueSA9IG5ldyBFdmVudEVtaXR0ZXI7XHJcbiAgQE91dHB1dCgpIG9uY29udGVudFN3aXBlOiBhbnkgPSBuZXcgRXZlbnRFbWl0dGVyO1xyXG4gIEBJbnB1dCgpIHNlYXJjaEVtb2ppUGxhY2Vob2xkZXJUZXh0OiBzdHJpbmc7XHJcbiAgQElucHV0KCkgc2VhcmNoQm94U3R5bGU6IGFueTtcclxuICBASW5wdXQoKSBlbW9qaU5vdEZvdW5kVGV4dDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpIG1hcnRFbW9qaU5vdEZvdW5kRkc6IHN0cmluZztcclxuXHJcbiAgbm90Rm91bmQ6IGJvb2xlYW47XHJcbiAgaW5pdGlhbEVtb2o6IGJvb2xlYW47XHJcblxyXG4gIEBWaWV3Q2hpbGQoJ2Vtb2ppQ29udGFpbmVyJykgZW1vamlDb250YWluZXI6IEVsZW1lbnRSZWY7XHJcbiAgLy8gQFZpZXdDaGlsZCgnc3dpcGVQYW5lJykgc3dpcGVQYW5lOiBFbGVtZW50UmVmO1xyXG5cclxuICBzZWFyY2hTZXQ6IGFueSA9IFtdO1xyXG4gIHJlY2VudEVtb3NGb3JTZWFyY2g6IGFueSA9IFtdO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJkOiBSZW5kZXJlcjIpIHtcclxuICAgIHRoaXMuaW5pdGlhbEVtb2ogPSBmYWxzZTtcclxuICAgIHRoaXMubm90Rm91bmQgPSBmYWxzZTtcclxuICB9XHJcblxyXG5cclxuICBzZWFyY2goZSkge1xyXG5cclxuICAgIGlmICghdGhpcy5pbml0aWFsRW1vaikge1xyXG4gICAgICAvLyBzYXZlIHRoZSByZWNlbnQgZW1vanNcclxuICAgICAgdGhpcy5yZWNlbnRFbW9zRm9yU2VhcmNoID0gdGhpcy5jYXRlZ29yeUVtb2ppU2V0O1xyXG4gICAgICBsZXQgc2VhcmNoU2V0ID0gW107XHJcbiAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgRU1PSklTLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc2VhcmNoU2V0ID0gc2VhcmNoU2V0LmNvbmNhdChFTU9KSVNbaV0uZW1vamlzKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnNlYXJjaFNldCA9IHNlYXJjaFNldDtcclxuICAgICAgdGhpcy5pbml0aWFsRW1vaiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBxdWVyeSA9IGUudGFyZ2V0LnZhbHVlLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgaWYgKHF1ZXJ5ICYmIHF1ZXJ5LnRyaW0oKSAhPT0gJycpIHtcclxuICAgICAgdGhpcy5jYXRlZ29yeUVtb2ppU2V0ID0gdGhpcy5zZWFyY2hTZXQuZmlsdGVyKGl0ZW0gPT4ge1xyXG4gICAgICAgIGlmIChpdGVtWzFdLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihxdWVyeSkgPiAtMSkge1xyXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmNhdGVnb3J5RW1vamlTZXQgPSB0aGlzLnJlY2VudEVtb3NGb3JTZWFyY2g7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5jYXRlZ29yeUVtb2ppU2V0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aGlzLm5vdEZvdW5kID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubm90Rm91bmQgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcblxyXG4gICAgLy8gbGlzdGVuIGZvciBzY3JvbGwgZXZlbnRcclxuICAgIHRoaXMucmQubGlzdGVuKHRoaXMuZW1vamlDb250YWluZXIubmF0aXZlRWxlbWVudCwgJ3Njcm9sbCcsIChlKSA9PiB7XHJcbiAgICAgIHRoaXMub25jb250ZW50c2Nyb2xsLmVtaXQoe1xyXG4gICAgICAgIHNjcm9sbFRvcDogdGhpcy5lbW9qaUNvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCxcclxuICAgICAgICBzY3JvbGxIZWlnaHQ6IHRoaXMuZW1vamlDb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHRcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBoYW5kbGUgc3dpcGUuLi5cclxuXHJcbiAgICB0aGlzLnN3aXBlZGV0ZWN0KHRoaXMuZW1vamlDb250YWluZXIubmF0aXZlRWxlbWVudCwgKHN3aXBlZGlyKSA9PiB7XHJcblxyXG4gICAgICBpZiAoc3dpcGVkaXIgPT09ICdsZWZ0JyB8fCBzd2lwZWRpciA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgIHRoaXMub25jb250ZW50U3dpcGUuZW1pdCh7XHJcbiAgICAgICAgICBkaXJlY3Rpb246IHN3aXBlZGlyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgc3dpcGVkZXRlY3QoZWwsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgY29uc3QgdG91Y2hzdXJmYWNlID0gZWw7XHJcbiAgICBsZXQgc3dpcGVkaXIsXHJcbiAgICAgIHN0YXJ0WCxcclxuICAgICAgc3RhcnRZLFxyXG4gICAgICBkaXN0LFxyXG4gICAgICBkaXN0WCxcclxuICAgICAgZGlzdFk7XHJcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAxNTA7IC8vIHJlcXVpcmVkIG1pbiBkaXN0YW5jZSB0cmF2ZWxlZCB0byBiZSBjb25zaWRlcmVkIHN3aXBlXHJcbiAgICBjb25zdCByZXN0cmFpbnQgPSAxMDA7IC8vIG1heGltdW0gZGlzdGFuY2UgYWxsb3dlZCBhdCB0aGUgc2FtZSB0aW1lIGluIHBlcnBlbmRpY3VsYXIgZGlyZWN0aW9uXHJcbiAgICBjb25zdCBhbGxvd2VkVGltZSA9IDMwMDsgLy8gbWF4aW11bSB0aW1lIGFsbG93ZWQgdG8gdHJhdmVsIHRoYXQgZGlzdGFuY2VcclxuICAgIGxldCBlbGFwc2VkVGltZSxcclxuICAgICAgc3RhcnRUaW1lO1xyXG4gICAgY29uc3QgaGFuZGxlc3dpcGUgPSBjYWxsYmFjaztcclxuXHJcbiAgICB0aGlzLnJkLmxpc3Rlbih0b3VjaHN1cmZhY2UsICd0b3VjaHN0YXJ0JywgKGUpID0+IHtcclxuICAgICAgY29uc3QgdG91Y2hvYmogPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xyXG4gICAgICBzd2lwZWRpciA9ICdub25lJztcclxuICAgICAgZGlzdCA9IDA7XHJcbiAgICAgIHN0YXJ0WCA9IHRvdWNob2JqLnBhZ2VYO1xyXG4gICAgICBzdGFydFkgPSB0b3VjaG9iai5wYWdlWTtcclxuICAgICAgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgIC8vIHJlY29yZCB0aW1lIHdoZW4gZmluZ2VyIGZpcnN0IG1ha2VzIGNvbnRhY3Qgd2l0aCBzdXJmYWNlXHJcblxyXG4gICAgICAvLyBVbmNvbW1lbnRlZCB0aGlzIHRvIGVuYWxlIHNjcm9sbCBpbiBkaXZcclxuICAgICAgLy8gZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICAvLyBVbmNvbW1lbnRlZCB0aGlzIHRvIGVuYWxlIHNjcm9sbCBpbiBkaXZcclxuICAgIC8vIHRoaXMucmQubGlzdGVuKHRvdWNoc3VyZmFjZSwgJ3RvdWNobW92ZScsIChlKSA9PiB7XHJcbiAgICAvLyBwcmV2ZW50IHNjcm9sbGluZyB3aGVuIGluc2lkZSBESVZcclxuICAgIC8vIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIC8vIH0pO1xyXG5cclxuICAgIHRoaXMucmQubGlzdGVuKHRvdWNoc3VyZmFjZSwgJ3RvdWNoZW5kJywgKGUpID0+IHtcclxuICAgICAgY29uc3QgdG91Y2hvYmogPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xyXG4gICAgICBkaXN0WCA9IHRvdWNob2JqLnBhZ2VYIC0gc3RhcnRYOyAvLyBnZXQgaG9yaXpvbnRhbCBkaXN0IHRyYXZlbGVkIGJ5IGZpbmdlciB3aGlsZSBpbiBjb250YWN0IHdpdGggc3VyZmFjZVxyXG4gICAgICBkaXN0WSA9IHRvdWNob2JqLnBhZ2VZIC0gc3RhcnRZOyAvLyBnZXQgdmVydGljYWwgZGlzdCB0cmF2ZWxlZCBieSBmaW5nZXIgd2hpbGUgaW4gY29udGFjdCB3aXRoIHN1cmZhY2VcclxuICAgICAgZWxhcHNlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTsgLy8gZ2V0IHRpbWUgZWxhcHNlZFxyXG4gICAgICBpZiAoZWxhcHNlZFRpbWUgPD0gYWxsb3dlZFRpbWUpIHsgLy8gZmlyc3QgY29uZGl0aW9uIGZvciBhd2lwZSBtZXRcclxuICAgICAgICBpZiAoTWF0aC5hYnMoZGlzdFgpID49IHRocmVzaG9sZCAmJiBNYXRoLmFicyhkaXN0WSkgPD0gcmVzdHJhaW50KSB7IC8vIDJuZCBjb25kaXRpb24gZm9yIGhvcml6b250YWwgc3dpcGUgbWV0XHJcbiAgICAgICAgICBzd2lwZWRpciA9IChkaXN0WCA8IDApID8gJ2xlZnQnIDogJ3JpZ2h0JzsgLy8gaWYgZGlzdCB0cmF2ZWxlZCBpcyBuZWdhdGl2ZSwgaXQgaW5kaWNhdGVzIGxlZnQgc3dpcGVcclxuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRpc3RZKSA+PSB0aHJlc2hvbGQgJiYgTWF0aC5hYnMoZGlzdFgpIDw9IHJlc3RyYWludCkgeyAvLyAybmQgY29uZGl0aW9uIGZvciB2ZXJ0aWNhbCBzd2lwZSBtZXRcclxuICAgICAgICAgIHN3aXBlZGlyID0gKGRpc3RZIDwgMCkgPyAndXAnIDogJ2Rvd24nOyAvLyBpZiBkaXN0IHRyYXZlbGVkIGlzIG5lZ2F0aXZlLCBpdCBpbmRpY2F0ZXMgdXAgc3dpcGVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgaGFuZGxlc3dpcGUoc3dpcGVkaXIpO1xyXG4gICAgICAvLyBVbmNvbW1lbnRlZCB0aGlzIHRvIGVuYWxlIHNjcm9sbCBpbiBkaXZcclxuICAgICAgLy8gZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcblxyXG4gIHBpY2tFbW9qaShlbW9qaSkge1xyXG4gICAgdGhpcy5vbnBpY2tlbW9qaS5lbWl0KHtcclxuICAgICAgZW1vamk6IGVtb2ppXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG5cclxuXHJcblxyXG59XHJcbiJdfQ==